import { Service } from 'typedi';
import { v4 as uuidv4 } from 'uuid';
import { Agent, AgentStep } from '../../domain/entities/Agent';
import { LLMProviderFactory } from '../../infrastructure/services/LLMProviderFactory';

interface ExecutionContext {
  agentId: string;
  executionId: string;
  steps: Record<string, any>; // Stores outputs of executed steps { [stepId]: result }
  inputs: Record<string, unknown>; // Initial inputs provided to the agent
  outputs: Record<string, unknown>; // Final outputs generated by 'output' steps
}

/**
 * Service responsible for executing defined agents.
 * It manages the state of a agent execution, handles different step types (LLM, transform, output),
 * resolves variables, and orchestrates the sequence of step executions.
 */
@Service()
export class AgentExecutionService {
  /**
   * Initializes the service with necessary dependencies.
   * @param llmProviderFactory - A factory to get instances of LLM providers.
   */
  constructor(private llmProviderFactory: LLMProviderFactory) {}
  
  /**
   * Executes a given agent with the provided inputs.
   * This is the main entry point for running a agent.
   *
   * Example:
   * const agent = //... get agent definition ...//;
   * const inputs = { query: "What is agentic AI?", userId: "user-123" };
   * const result = await agentExecutionService.executeAgent(agent, inputs);
   * // result might be: { executionId: '...', agentId: '...', success: true, outputs: { answer: 'Agentic AI is...' } }
   *
   * @param agent - The agent definition to execute.
   * @param inputs - A map of input names to their values.
   * @returns A promise that resolves to the execution result, including outputs or error information.
   */
  async executeAgent(agent: Agent, inputs: Record<string, unknown>): Promise<Record<string, unknown>> {
    // Create a new execution context
    const executionId = uuidv4();
    const context: ExecutionContext = {
      agentId: agent.id,
      executionId,
      steps: {},
      inputs,
      outputs: {},
    };
    
    try {
      // Validate inputs against agent definition
      this.validateInputs(agent, inputs);
      
      // Find the entry points (steps with no incoming connections)
      const entrySteps = this.findEntrySteps(agent);
      
      // Execute each entry step
      for (const step of entrySteps) {
        await this.executeStep(step, agent, context);
      }
      
      return {
        executionId,
        agentId: agent.id,
        success: true,
        outputs: context.outputs,
      };
    } catch (error) {
      return {
        executionId,
        agentId: agent.id,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
  
  /**
   * Validates that all required inputs defined in the agent are present in the provided inputs.
   * Throws an error if a required input is missing and has no default value.
   *
   * Example:
   * // Agent defines input 'customerId' as required.
   * const inputs = { orderId: "order-456" };
   * // this.validateInputs(agent, inputs); // Throws Error("Required input 'customerId' is missing")
   *
   * @param agent - The agent definition containing input specifications.
   * @param inputs - The inputs provided for the execution.
   * @throws {Error} If a required input is missing.
   */
  private validateInputs(agent: Agent, inputs: Record<string, unknown>): void {
    for (const inputDef of agent.definition.inputs) {
      if (inputDef.required && !(inputDef.name in inputs) && !('default' in inputDef)) {
        throw new Error(`Required input '${inputDef.name}' is missing`);
      }
    }
  }
  
  /**
   * Identifies the starting steps of the agent.
   * These are steps that do not have any other steps leading into them ('next' pointing to them).
   *
   * Example:
   * // Agent: StepA -> StepB, StepC -> StepB
   * // this.findEntrySteps(agent); // Returns [StepA, StepC]
   *
   * @param agent - The agent definition.
   * @returns An array of AgentStep objects that are entry points.
   */
  private findEntrySteps(agent: Agent): AgentStep[] {
    // Get all step IDs that are referenced as 'next' steps
    const nextStepIds = new Set<string>();
    for (const step of agent.definition.steps) {
      if (step.next) {
        for (const nextId of step.next) {
          nextStepIds.add(nextId);
        }
      }
    }
    
    // Find steps that are not referenced as 'next' steps
    return agent.definition.steps.filter(step => !nextStepIds.has(step.id));
  }
  
  /**
   * Executes a single step within the agent, recursively calling itself for subsequent steps.
   * It handles different step types and manages the execution context.
   * Prevents re-execution of already completed steps within the same execution context.
   *
   * @param step - The step to execute.
   * @param agent - The overall agent definition.
   * @param context - The current execution context (state).
   * @returns A promise that resolves when the step and its subsequent steps are completed.
   * @throws {Error} If the step execution fails or a next step is not found.
   */
  private async executeStep(
    step: AgentStep,
    agent: Agent,
    context: ExecutionContext
  ): Promise<void> {
    // Check if step already executed
    if (step.id in context.steps) {
      return;
    }
    
    try {
      // Execute step based on its type
      let stepResult: any;
      
      switch (step.type) {
      case 'llm':
        stepResult = await this.executeLLMStep(step, context);
        break;
      case 'transform':
        stepResult = this.executeTransformStep(step, context);
        break;
      case 'output':
        this.executeOutputStep(step, context);
        break;
      default:
        throw new Error(`Unknown step type: ${step.type}`);
      }
      
      // Store the result in context
      context.steps[step.id] = stepResult;
      
      // Execute next steps
      if (step.next) {
        for (const nextStepId of step.next) {
          const nextStep = agent.definition.steps.find(s => s.id === nextStepId);
          if (nextStep) {
            await this.executeStep(nextStep, agent, context);
          } else {
            throw new Error(`Next step '${nextStepId}' not found`);
          }
        }
      }
    } catch (error) {
      throw new Error(`Error executing step '${step.id}': ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Executes a step of type 'llm'.
   * It resolves variables in the prompt and system prompt, calls the appropriate LLM provider,
   * and returns the generation result.
   *
   * Example:
   * // step config: { providerName: 'openai', prompt: "Summarize: {{inputs.document}}", model: "gpt-4" }
   * // context.inputs: { document: "Long text..." }
   * // result = await this.executeLLMStep(step, context); // result might be { text: "Short summary..." }
   *
   * @param step - The LLM step definition.
   * @param context - The current execution context.
   * @returns A promise that resolves to the result from the LLM provider.
   */
  private async executeLLMStep(
    step: AgentStep,
    context: ExecutionContext
  ): Promise<any> {
    const { providerName = step.provider, prompt, systemPrompt, temperature, maxTokens, model } = step.config;
    
    // Replace variables in prompt
    const resolvedPrompt = this.resolveVariables(prompt as string, context);
    const resolvedSystemPrompt = systemPrompt ? this.resolveVariables(systemPrompt as string, context) : undefined;
    
    // Get the provider
    const provider = this.llmProviderFactory.getProvider(providerName as string);
    
    // Generate completion
    const response = await provider.generateCompletion({
      text: resolvedPrompt,
      systemPrompt: resolvedSystemPrompt,
      temperature: temperature as number,
      maxTokens: maxTokens as number,
      model: model as string,
    });
    
    return response;
  }
  
  /**
   * Executes a step of type 'transform'.
   * It applies a defined operation (e.g., 'parseJson', 'toString') to an input variable.
   *
   * Example:
   * // step config: { operation: 'parseJson', inputVariable: 'steps.llmStep.result.text' }
   * // context.steps.llmStep.result.text: '{ "key": "value" }'
   * // result = this.executeTransformStep(step, context); // result will be { key: "value" }
   *
   * @param step - The transform step definition.
   * @param context - The current execution context.
   * @returns The result of the transformation.
   * @throws {Error} If the operation is unknown or fails (e.g., JSON parsing error).
   */
  private executeTransformStep(step: AgentStep, context: ExecutionContext): any {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { operation, inputVariable, outputVariable } = step.config;
    
    // Get the input value
    const inputValue = this.resolveVariableValue(inputVariable as string, context);
    
    // Apply the transformation
    let result: any;
    
    switch (operation) {
    case 'parseJson':
      try {
        result = JSON.parse(inputValue as string);
      } catch (error) {
        throw new Error(`Failed to parse JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
      break;
    case 'toString':
      result = String(inputValue);
      break;
    default:
      throw new Error(`Unknown transform operation: ${operation}`);
    }
    
    return result;
  }
  
  /**
   * Executes a step of type 'output'.
   * It resolves the value specified in the step config and assigns it to the final outputs
   * in the execution context, using the specified output name.
   *
   * Example:
   * // step config: { outputName: 'finalSummary', value: '{{steps.summaryStep.result}}' }
   * // context.steps.summaryStep.result: "This is the final summary."
   * // this.executeOutputStep(step, context);
   * // context.outputs will now contain { finalSummary: "This is the final summary." }
   *
   * @param step - The output step definition.
   * @param context - The current execution context.
   */
  private executeOutputStep(step: AgentStep, context: ExecutionContext): void {
    const { outputName, value } = step.config;
    
    // Resolve the value
    const resolvedValue = this.resolveVariableValue(value as string, context);
    
    // Set as output
    context.outputs[outputName as string] = resolvedValue;
  }
  
  /**
   * Replaces placeholders like `{{variable.path}}` within a string with their
   * corresponding values from the execution context.
   *
   * Example:
   * // text: "User query was: {{inputs.query}}. Result: {{steps.llmStep.result.text}}"
   * // context: { inputs: { query: "Hello" }, steps: { llmStep: { result: { text: "Hi" } } } }
   * // this.resolveVariables(text, context);
   * // Returns: "User query was: Hello. Result: Hi"
   *
   * @param text - The string containing variables to resolve.
   * @param context - The execution context holding the variable values.
   * @returns The string with variables substituted.
   */
  private resolveVariables(text: string, context: ExecutionContext): string {
    return text.replace(/\{\{(.*?)\}\}/g, (match, variable) => {
      return String(this.resolveVariableValue(variable.trim(), context));
    });
  }
  
  /**
   * Retrieves a value from the execution context using a dot-notation path.
   * Accesses values within `inputs`, `steps`, etc.
   * Returns an empty string if the path is invalid or the value is undefined/null.
   *
   * Example:
   * // path: "steps.dataFetch.result.users[0].name"
   * // context: { steps: { dataFetch: { result: { users: [{ name: 'Alice' }] } } } }
   * // this.resolveVariableValue(path, context); // Returns "Alice"
   *
   * // path: "inputs.nonExistent"
   * // context: { inputs: { query: "test" } }
   * // this.resolveVariableValue(path, context); // Returns ""
   *
   * @param path - The dot-notation path (e.g., 'inputs.userId', 'steps.step1.output').
   * @param context - The execution context.
   * @returns The resolved value, or an empty string if not found.
   */
  private resolveVariableValue(path: string, context: ExecutionContext): unknown {
    const parts = path.split('.');
    let value: any = context; // Start searching from the root context object
    
    for (const part of parts) {
      if (value === undefined || value === null) {
        return '';
      }
      value = value[part];
    }
    
    return value === undefined ? '' : value;
  }
} 